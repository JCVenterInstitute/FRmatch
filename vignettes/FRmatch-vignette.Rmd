---
title: "FR-Match: A cell type matching algorithm for single cell RNA sequencing (scRNAseq) data"
author: 
- "Yun (Renee) Zhang, zhangy@jcvi.org"
# - "Brian Aevermann, baeverma@jcvi.org"
# - "Richard Scheuermann, RScheuermann@jcvi.org"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{FR-Match: A cell type matching algorithm for single cell RNA sequencing (scRNAseq) data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  catch = TRUE,
  collapse = TRUE,
  comment = "##"
)
```

# Overview

## Input data

FR-Match is a method to integrate scRNAseq cell type data from two independently conducted experiments: query and reference. For each experiment, FR-Match takes in the following input data:

- Reference dataset
    + A cell-by-gene expression matrix
    + Cell type cluster membership for each cell
    + ***Informative* marker genes for the reference cell types**
- Query dataset
    + A cell-by-gene expression matrix
    + Cell type cluster membership for each cell

## Workflow

General steps of FR-Match include:

- Feature selection/dimensionality reduction using the *supervised* [NS-Forest](https://github.com/JCVenterInstitute/NSForest) marker gene selection algorithm or other *informative* marker gene set per user's choice. Our choice of the NS-Forest marker gene selection provides a minimum set of marker genes that maximize the classification power of differentiating clusters in the reference dataset. 
-	Construct minimum spanning trees for each pair of query and reference clusters.
-	Calculate FR statistics and p-values based on the minimum spanning tree plots.

![Overview of FR-Match for cross-comparison between two scRNAseq experiments.](FRmatch-scheme-v2.png){width=100%}

## Installation

To install from GitHub repository,
```{r, install, eval=FALSE}
install.packages("devtools")
devtools::install_github("JCVenterInstitute/FRmatch")
```

After successful installation, load FR-Match and other useful packages to your R environment.
```{r, package, message=FALSE}
library(FRmatch)
library(SingleCellExperiment)
library(dplyr)
library(tibble)
```

## Shiny App

We complement this package with a Shiny App, which can be launched by calling the following function.
```{r, shinyapp, eval=FALSE}
runShiny()
```


# Getting input data ready 

There are many pieces of data information needed for conducting various scRNAseq data analyses. We choose to use the `SingleCellExperiment` class, which is a convenient container for single cell genomics data. For instructions on how to construct a `SingleCellExperiment` object, please see [An introduction to the SingleCellExperiment class](https://www.bioconductor.org/packages/devel/bioc/vignettes/SingleCellExperiment/inst/doc/intro.html).

For FR-Match data object, the following data are essential:

- a gene expression data matrix (`assay()`)
- cell type cluster labels (`colData()`)
- NS-Forest or your own marker genes for the reference dataset (`rowData()`)

In addition, metadata (`@metadata`) such as F-beta score and cluster order are not essential for the core matching algorithm, but these information will facilitate visualization and other customized analysis tools provided in this package.

## An example data object

In this package, we include an example data object `sce.example`. More details please see `help("sce.example")`. A quick look at the data object is below.
```{r, data, warning=FALSE, message=FALSE}
data(sce.example)
sce.example
```

In this example data, there are 16487 genes (in rows) and 865 cells (in columns). A quick check of the 15 clusters and their sizes.

```{r, cluster-size, , warning=FALSE, message=FALSE}
knitr::kable(table(colData(sce.example)$cluster_membership), col.names=c("Cluster", "Size"), row.names=1:15)
```

# FR-Match

For illustration purpose, we show in this vignette how FR-Match works in the context of cross-validation with the example data object. 

## Create toy datasets

We use two-fold cross-validation to randomly split the example dataset into two sub-datasets: one serving as the query dataset and the other serving as the reference dataset. We randomly select half of the cells in proportion to their cluster sizes.

```{r, data-split, warning=FALSE, message=FALSE}
set.seed(999)
all <- colData(sce.example) %>% as.data.frame() %>% rownames_to_column()
sam1 <- all %>% group_by(cluster_membership) %>% sample_frac(.5)
sam2 <- dplyr::setdiff(all, sam1)

sce.sam1 <- sce.example[,sam1$rowname]
sce.sam2 <- sce.example[,sam2$rowname]
```

Now, look at the cluster sizes in these two toy datasets.
```{r, clusterSize, fig.height = 9, fig.width = 7}
plot_clusterSize(sce.sam1, sce.sam2)
```

## Bracode plot with marker genes

We utilize the informative marker genes for dimensionality reduction. Good marker genes display on-off binary expression pattern producing, in combination, a unique gene expression “barcode” for each cell cluster. We provide the `plot_cluster_by_markers()` function for plotting the marker gene expression patterns for a random set of cells in each cluster.

```{r, barcode-plot, fig.height = 5, fig.width = 7}
plot_cluster_by_markers(sce.sam1, cluster.name = "i1_i90_COL5A2_Ndnf_Car4")
```

## Run `FRmatch`

The `FRmatch()` function is a wrapper function that take in two input arguments, `sce.query =` and `sce.ref =`. By performing this function, it carries out our workflow in default setting. Key steps are reported while running. To start, let's regard `sce.sam1` as the query dataset and `sce.sam2` as the reference dataset.

```{r, FRmatch12, warning=FALSE, message=FALSE}
rst12 <- FRmatch(sce.query = sce.sam1, sce.ref = sce.sam2)
```

Also, we may swap the query and reference datasets, and perform FR-Match from the other direction. This step may not make a big difference in this example, since our two datasets are indeed split from the same data object, i.e. same set of marker genes. In practice, if we want to match between two independently conducted experiments (for example, each of them might focus on a different specimen region and therefore inducing different cell type clusters with different marker genes), the direction of matching would lead to quiet different matching results. In the end, we recommend to perform both directions of matching, and conclude with a consensus matching results from both directions. 

```{r, FRmatch21, warning=FALSE, message=FALSE}
rst21 <- FRmatch(sce.query = sce.sam2, sce.ref = sce.sam1)
```

This wrapper function returns a list of results. The best way to present these results is to use our customized plotting functions.

## Plot bi-directional matching results

The final matching results from both directions can be combined using the `plot_bi_FRmatch()` function.

```{r, FRmatch-bi-plot, fig.height = 5, fig.width = 7}
plot_bi_FRmatch(rst12, rst21, reorder = FALSE)
```

In this two-fold cross-validation, we know that the matches should be along the diagonal of the above plot. In this example, other than the expected diagonal matches, the i6 and i9 clusters (both are closely related inhibitory nueronal cell clusters in this example data) are identified as matched clusters due to smaller cluster sizes after data splitting. Some other remarks are:

- The argument `reorder = FALSE` is enforced in this example, since we want to show the diagonal alignment in the plot. By default, `reorder = TRUE` where the plotted columns are reordered (rows are fixed) in a way that we think would aid the interpretation of the matching results.
- Careful readers may notice that not all clusters are shown on the plot. Indeed, not all clusters are passed to the matching algorithm. In the default setting of `FRmatch`, query and reference clusters with less 10 cells are filtered out. This is tunable using the `filter.size =` argument in `FRmatch()` function.


## Plot one-directional matching results

We also provide the function `plot_FRmatch()` with default `type = matches` and option `type = padj` to visualize one-directional matching results.

```{r, FRmatch-plot-matches, fig.height = 5, fig.width = 7}
plot_FRmatch(rst12, reorder = FALSE)
```
```{r, FRmatch-plot-padj, fig.height = 4, fig.width = 7}
plot_FRmatch(rst12, type = "padj", reorder = FALSE)
```

From the adjusted p-value plot, we see that the significance of the match of i6 and i9 clusters is very marginal. We may obtain the actual values from these plots using the `return.value = TRUE` in the corresponding plotting function.

<!-- ## Non-zero expression plot -->

<!-- We also provide a supporting function that calculates and plots the "% expressed per marker gene per cluster" for the \code{FRmatch} input data object. The percentage is defined as -->

<!-- > number of cells that express the marker gene in the cluster / cluster size -->

<!-- The NS-Forest algorithm is designed to select the minimum set of *binary* genes for each cluster, which has the "best" classification score (measured by F-measure) differentiating the cluster from all other clusters pooling together. The *binaryness* is desirable because it is pragmatically important for many downstream use cases of marker genes. Therefore, we are looking for few dropouts of the marker genes in the cluster that they mark, which can be checked using -->

<!-- ```{r, dropout, fig.height=8, fig.width=7} -->
<!-- plot_nonzero(sce.example, return.value=FALSE, return.plot=TRUE) -->
<!-- ``` -->

# Other useful functions

## Friedman-Rafsky test 

We also implemented our own function `FRtest()` for [Friedman-Rafsky (FR) test](https://projecteuclid.org/download/pdf_1/euclid.aos/1176344722) with customized options. FR test is a multivariate generalization of non-parametric two-sample test. It is a graphical model based on the concept of [minimum spanning tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree) (MST). The MST provides a way to visualize high-dimensional clustered data in a low-dimensional visualization. A minimal working example of FR test and MST visualization is below.

```{r, FR-test, fig.height = 7, fig.width = 7}
# simulate some synthetic data from the same distribution
samp1 <- matrix(rnorm(1000), nrow = 50) #a 50-by-20 matrix: 50 dimensional, 20 data points
samp2 <- matrix(rnorm(1000), nrow = 50) #a 50-by-20 matrix: 50 dimensional, 20 data points
# FR test with MST plot
FRtest(samp1, samp2, plot.MST = TRUE, main = "Minimum spanning tree")
```

In the above test, the p-value suggests that no difference between the two simulated samples. 

We encourage our users to visually examine their interested cell type clusters on MST plots.

# Session info
```{r, sessionInfo}
sessionInfo()
```
